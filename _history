{"entries":[{"timestamp":1753047543039,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":188,"length1":65,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":217,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"promise.ts","value":"enum PromiseState {\n    Pending,\n    Fulfilled,\n    Rejected\n}\n\nclass Promise<T> {\n    private state: PromiseState = PromiseState.Pending;\n    private value: T = null;\n    private error: any = null;\n    private thenCallbacks: ((value: T) => void)[] = [];\n    private catchCallbacks: ((err: any) => void)[] = [];\n    private finallyCallbacks: (() => void)[] = [];\n\n    constructor(executor: (resolve: (value: T) => void, reject: (err: any) => void) => void) {\n        try {\n            // Inline arrow functions capture 'this' implicitly\n            executor(\n                (val: T) => this.resolve(val),\n                (err: any) => this.reject(err)\n            );\n        } catch (e) {\n            this.reject(e);\n        }\n    }\n\n    private resolve(val: T) {\n        if (this.state !== PromiseState.Pending) return;\n\n        this.state = PromiseState.Fulfilled;\n        this.value = val;\n        for (let cb of this.thenCallbacks) {\n            cb(val);\n        }\n        this.runFinalizers();\n    }\n\n    private reject(err: any) {\n        if (this.state !== PromiseState.Pending) return;\n\n        this.state = PromiseState.Rejected;\n        this.error = err;\n        for (let cb of this.catchCallbacks) {\n            cb(err);\n        }\n        this.runFinalizers();\n    }\n\n    then(callback: (value: T) => void): Promise<T> {\n        const safeCallback = (val: T) => {\n            try {\n                callback(val);\n            } catch (e) {\n                this.reject(e);\n            }\n        };\n\n        if (this.state === PromiseState.Fulfilled) {\n            safeCallback(this.value);\n        } else if (this.state === PromiseState.Pending) {\n            this.thenCallbacks.push(safeCallback);\n        }\n\n        return this;\n    }\n\n    catch(callback: (err: any) => void): Promise<T> {\n        if (this.state === PromiseState.Rejected) {\n            callback(this.error);\n        } else if (this.state === PromiseState.Pending) {\n            this.catchCallbacks.push(callback);\n        }\n        return this;\n    }\n\n    finally(callback: () => void): Promise<T> {\n        if (this.state !== PromiseState.Pending) {\n            callback();\n        } else {\n            this.finallyCallbacks.push(callback);\n        }\n        return this;\n    }\n\n    private runFinalizers() {\n        for (let cb of this.finallyCallbacks) {\n            cb();\n        }\n    }\n}"},{"type":"added","filename":"string.ts","value":"// Add your code here\ninterface String {\n    startswith(With:string):boolean;\n}\n\nnamespace helpers {\n    export function STR_STARTSWITH(Str:string,With:string) {\n       return Str.substr(0,With.length-1) == With\n    }\n}"}]},{"timestamp":1753048140803,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":233,"length1":110,"diffs":[[1,"        \"string.ts\"\n"]]}]},{"type":"edited","filename":"string.ts","patch":[{"start1":0,"length1":94,"diffs":[[1,"// Add your code here\n"]]},{"start1":41,"length1":313,"diffs":[[1,"    startswith(With:string):boolean;\n"]]},{"start1":81,"length1":47,"diffs":[[1,""]]},{"start1":101,"length1":130,"diffs":[[1,"    export function STR_STARTSWITH(Str:string,With:string) {\n       return Str.substr(0,With.length-1) == With\n"]]},{"start1":218,"length1":973,"diffs":[[1,"}"]]}]},{"type":"added","filename":"set.ts","value":"// ðŸ”¢ Simple Set class for unique values\n\nclass Set<T> {\n    private items: T[] = [];\n    \n    constructor() {}\n\n    // Adds value if it's not already present\n    add(value: T): Set<T> {\n        if (!this.has(value)) {\n            this.items.push(value);\n        }\n        return this;\n    }\n\n    // Checks if value exists in the set\n    has(value: T): boolean {\n        for (let item of this.items) {\n            if (item == value) return true;\n        }\n        return false;\n    }\n\n    // Removes a value from the set\n    delete(value: T): boolean {\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i] == value) {\n                this.items.removeAt(i);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Empties the set\n    clear(): void {\n        this.items = [];\n    }\n\n    // Returns number of elements\n    size(): number {\n        return this.items.length;\n    }\n\n    // Returns array of values for iteration or display\n    values(): T[] {\n        return this.items.slice();\n    }\n}"},{"type":"added","filename":"map.ts","value":"class Map<K, V> {\n    private keys: K[] = [];\n    private values: V[] = [];\n    \n    constructor() {}\n\n    // Sets a key-value pair\n    set(key: K, value: V): Map<K, V> {\n        let index = this.indexOfKey(key);\n        if (index >= 0) {\n            this.values[index] = value;\n        } else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    }\n\n    // Gets the value associated with a key\n    get(key: K): V {\n        let index = this.indexOfKey(key);\n        if (index >= 0) {\n            return this.values[index];\n        }\n        return null;\n    }\n\n    // Checks if the map contains a key\n    has(key: K): boolean {\n        return this.indexOfKey(key) >= 0;\n    }\n\n    // Deletes a key-value pair\n    delete(key: K): boolean {\n        let index = this.indexOfKey(key);\n        if (index >= 0) {\n            this.keys.removeAt(index);\n            this.values.removeAt(index);\n            return true;\n        }\n        return false;\n    }\n\n    // Removes all key-value pairs\n    clear(): void {\n        this.keys = [];\n        this.values = [];\n    }\n\n    // Returns the number of entries\n    size(): number {\n        return this.keys.length;\n    }\n\n    // Returns a copy of all keys\n    keysArray(): K[] {\n        return this.keys.slice();\n    }\n\n    // Returns a copy of all values\n    valuesArray(): V[] {\n        return this.values.slice();\n    }\n\n    // Iterates over each key-value pair\n    forEach(callback: (key: K, value: V) => void): void {\n        for (let i = 0; i < this.keys.length; i++) {\n            callback(this.keys[i], this.values[i]);\n        }\n    }\n\n    // Internal: gets index of key\n    private indexOfKey(key: K): number {\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] == key) return i;\n        }\n        return -1;\n    }\n}"},{"type":"added","filename":"obesrable.ts","value":"// ðŸ“¡ Observable class for reactive programming\n\nclass Observable<T> {\n    private listeners: ((value: T) => void)[] = [];\n\n    // Subscribe to value updates\n    subscribe(callback: (value: T) => void): void {\n        this.listeners.push(callback);\n    }\n\n    // Unsubscribe from updates\n    unsubscribe(callback: (value: T) => void): void {\n        for (let i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i] == callback) {\n                this.listeners.removeAt(i);\n                break;\n            }\n        }\n    }\n\n    // Broadcast a new value\n    next(value: T): void {\n        for (let cb of this.listeners) {\n            cb(value);\n        }\n    }\n\n    // Remove all subscribers\n    clear(): void {\n        this.listeners = [];\n    }\n}"},{"type":"added","filename":"abortcontroller.ts","value":"// ðŸ›‘ Custom AbortController for cooperative cancellation\n\nclass AbortController {\n    public readonly signal: AbortSignal;\n\n    constructor() {\n        this.signal = new AbortSignal();\n    }\n\n    // Cancels the signal\n    abort(): void {\n        this.signal.trigger();\n    }\n}\n\nclass AbortSignal {\n    private aborted: boolean = false;\n    private listeners: (() => void)[] = [];\n\n    constructor() {}\n\n    // Check if already aborted\n    get isAborted(): boolean {\n        return this.aborted;\n    }\n\n    // Subscribe to abort event\n    onAbort(callback: () => void): void {\n        if (this.aborted) {\n            callback();\n        } else {\n            this.listeners.push(callback);\n        }\n    }\n\n    // Trigger all listeners\n    trigger(): void {\n        if (this.aborted) return;\n        this.aborted = true;\n        for (let cb of this.listeners) {\n            cb();\n        }\n    }\n}\nasync function y() {\n    return 0\n}\nasync function x() {\n    return await y()\n}\n"}]},{"timestamp":1753048732232,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"abortcontroller.ts","patch":[{"start1":897,"length1":0,"diffs":[[1,"async function y() {\n    return 0\n}\nasync function x() {\n    return await y()\n}\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1753047543038,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Promise<somehting>\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1753048773474}